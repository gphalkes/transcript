WARNING: this document is not finished!
TODO: possibly extend for more complex tables, with more initial states

Table file format
=================

All fields are in Big Endian format. The "string" format consists of a 1 byte
length field, followed by 4 bytes representing the string. Codepoints
that are unused are represented by an all 1s pattern.


Header
------

The header fields are described in the following table. The first two fields
are guaranteed to be the same for all versions of the file format. All other
information describes version 0 of the file format.

Field                        | Bytes
-----------------------------------------------------------------
Magic                        | 4 (54h 33h 43h 4Dh, T3CM)
Format version               | 4
-----------------------------------------------------------------
Flags                        | 1 (See defined flag values below)
Subchar                      | string
Subchar initial state        | 1
Subchar1                     | 1
Num. of shift sequences      | 1
Number of states (code page) | 1 (0 means 1, etc)
Total range entries (code p) | 2 (0 means 1, etc)
Number of states (unicode)   | 1 (0 means 1, etc)
Total range entries (unicode)| 2 (0 means 1, etc)
Default to-unicode flags     | 1
Default from-unicode flags   | 1
Final codepage action size   | 1

The Flags field is a bit mask. The following flags are defined (0 is least
significant bit).

Bit   | Meaning
---------------------------------------------------
0     | A table with information about the from-unicode transformation is available
1     | A table with information about the to-unicode transformation is available
2     | A table with m:n mappings is available
3     | Subchar1 is valid
4     | Code page is of MBCS type (state 1 is also intial state)
5-7   | Reserved (must be 0)

After the header follow the definitions of the shift sequences, followed by the
definitions of the states. The lookup tables are stored at the end of the file.


Shift sequences
---------------

The shift sequences are stored separately for easy conversion from unicode. Each
shift sequence is defined as follows:

Field                   | Bytes
---------------------------------------------------
From state              | 1
To state                | 1
Sequence                | string (is valid in state machine)


State table
-----------

For each state the following is stored

Field                   | Bytes
---------------------------------------------------
##Flags                   | 1 (See defined flag values below)
Number of range entries | 1 (0 means 1, etc)

##The Flags field is a bit mask. The following flags are defined (0 is least
##significant bit).
##
##Bit   | Meaning
##---------------------------------------------------
##0     | State is an initial state
##1-7   | Reserved (must be 0)


Range entry
------------

Field                   | Bytes
---------------------------------------------------
Low end of range        | 1
Next state              | 1
Action                  | 1 (See list of action values below)

The Action field can have the following values:

Value | Meaning
---------------------------------------------------
0     | Byte is the last byte of a sequence encoding a character
1     | Byte is an intermediate byte of a sequence
2     | Byte is the last byte of a sequence encoding an unassigned code point
3     | Byte is the last byte of a sequence encoding a state shift
4     | Byte is illegal at this point in the input
5-255 | Reserverd


Lookup tables
-------------

Following the states, two to four lookup tables are defined. The first lookup
table is a mapping from linear codepage numbers to unicode codepoints. The
second lookup table is a mapping from linear unicode numbers to codepage bytes.
Next are two optional tables (see the Flags field in the header), which encode
information about the transformation.

The two optional tables are (in order) a table with information about the
to-unicode transformation and a table with information about the from-unicode
transformation.

The format of the data for the from- and to-unicode flag tables are specified
by a format byte preceeding the table. This byte indicates both the size and
meaning of each entry.

For the to-unicode table, the lower 4 bits of the header byte can have the
following values:

Value | Meaning
---------------------------------------------------
1     | 2 bit entries, representing bits A & B
2     | 2 bit entries, representing bit C
3     | 4 bit entries, representing bits A through C

For the to-unicode flags the following values are defined:

Bit   | Meaning
---------------------------------------------------
A     | Mapping is a fallback (i.e. maps to the same codepoint as another)
B     | The codepage number is used as the first codepage number in a m:n conversion
C     | The mapping maps to a private use character to allow round-trip conversion

For the from-unicode table, the lower 4 bits of the header byte can have the
following values:

Value | Meaning
---------------------------------------------------
1     | 2 bit entries, representing bits A & B
2     | 2 bit entries, representing bits C & D
3     | 4 bit entries, representing bits A, B, C & D
4     | 2 bit entries, representing bits E & F
5     | 4 bit entries, representing bits A, B, E & F
6     | 4 bit entries, representing bits C, D, E & F
15    | 8 bit entries, representing bits A through F

For the from-unicode flags the following values are defined:

Bit   | Meaning
---------------------------------------------------
A-B   | A number representing the number of bytes in the code page sequence
C     | The mapping is not available
D     | Mapping is a fallback (i.e. a similar looking character)
E     | The mapping is not available and the subchar1 character should be used
F     | The codepoint is used as the first codepoint in a m:n conversion

Note that a to-unicode fallback is different from a from-unicode fallback. A
to-unicode fallback means that the same character is encoded in the input
character set more than once, while a from-unicode fallback means that there is
no character available in the target character set, only a character that is
"similar". Similar in this context means that a human may find it useful to
have this conversion performed, but it is by no means an exact representation
of the original codepoint.

Also note that the availability of a to-unicode mapping should be determined
by checking whether the mapped value is unequal to FFFF. For the to-unicode
mappings there also is no length field because the codepoints are encoded as
UTF-16BE, such that the length can be determined from the encoding.

If bit 7 of the header byte is set, then the flags are saved as a single level
trie. The header byte is then followed by a list of 16 bit indices. These
indices are into the next table of 16 byte blocks, which is itself preceeded by
a 2 byte count of the number of blocks - 1. This holds for both the to- and
from-unicode flags tables. //FIXME: this description needs to be improved [include calculation of lengths]


Finally, there is an optional m:n mapping table. This table consists of a
single 4 byte number indicating the number of m:n mappings, followed by the
mappings. The mappings should be sorted in ascending order of codepage bytes.

Field                      | Bytes
---------------------------------------------------
Number of codepoints       | 1 (1 through 31)
[ codepoints ]+            | [ UTF-16BE ]+
Number of code page bytes  | 1 (1 through 19)
[ code page bytes ]+       | [ Indicated by previous field ]+
