import os
import subprocess

package = 'libtranscript'
srcdirs = [ 'src', 'src.util' ]
excludesrc = '/(Makefile|TODO.*|SciTE.*|run\.sh|test\.c|aliases_full\.txt)$'
auxsources = [ 'src/generic_fallbacks.[ch]', 'src/tables/*.c' ]
auxfiles = [ 'doc/API', 'doc/motivation.txt', 'doc/motivation.html' ]
extrabuilddirs = [ 'doc' ]
versioninfo = '1:0:0'

def prebuild(mkdist):
	subprocess.call(['./ucm/generate_ltc.sh', '-r', '-n'])

def get_replacements(mkdist):
	libversion = versioninfo.split(':', 2)[0]

	# Generating the rules for the modules is somewhat hard, because they
	# are also autogenerated in the Makefile. However, I don't want to
	# duplicate the logic to generate them, because that makes updating them
	# harder. So we extract them from the Makefile here.

	# First find the MODULES := line. This will tell us the names of the
	# modules to build
	rules = subprocess.check_output(['make', '-C', 'src', '-p', '-n'])
	rules = rules.split('\n')
	for rule in rules:
		if rule.startswith('MODULES '):
			# Line starts with MODULES :=, so only take parts 2 and further
			modules = rule.split()[2:]
			break

	# Then, for each module, find the modules/<module>.la rule. That will tell
	# us which objects to build for each module. For each such rule, we
	# generate a linker rule, which combines all the objects into the desired
	# module target.

	# The original Makefile has an order only target for the library. We use
	# the | to find the split point for the objects.
	module_rules = []
	for module in modules:
		search_for = 'modules/' + module + '.la:'
		for rule in rules:
			if rule.startswith(search_for):
				break
		if not rule.startswith(search_for):
			print >>sys.stderr, 'Could not find rule for module %s' % module
		module_objects = rule[len(search_for):rule.find('|')].replace('.objects', 'src').split()
		module_rules.append('src/' + search_for + ' '.join(module_objects) + ' src/libtranscript.la')
		module_rules.append('	$(SILENTLDLT) $(LIBTOOL) $(SILENCELT) --mode=link --tag=CC $(CC) -shared -module -avoid-version -shrext .ltc ' +
							'$(CFLAGS) $(LDFLAGS) -o $@ %s $(LDLIBS) -rpath $(libdir)/transcript%s' % (' '.join(module_objects), libversion))

	return [
		{
			'tag': '<VERSION>',
			'replacement': mkdist.version
		},
		{
			'tag': '^#define TRANSCRIPT_VERSION .*',
			'replacement': '#define TRANSCRIPT_VERSION ' + mkdist.get_version_bin(),
			'files': [ 'src/key.h' ],
			'regex': True
		},
		{
			'tag': '<OBJECTS>',
			'replacement': " ".join(mkdist.sources_to_objects(mkdist.include_by_regex(mkdist.sources, '^src/[^/]+$'), '\.c$', '.lo')),
			'files': [ 'mk/libtranscript.in' ]
		},
		{
			'tag': '<TABLES>',
			'replacement': " ".join(mkdist.sources_to_objects(mkdist.include_by_regex(mkdist.sources, '^src/tables/'), '\.c$', '.lo')),
			'files': [ 'mk/libtranscript.in' ]
		},
		{
			'tag': '<MODULES>',
			'replacement': " ".join([ 'src/modules/%s.la' % module for module in modules ]),
			'files': [ 'mk/libtranscript.in' ]
		},
		{
			'tag': '<MODULE_RULES>',
			'replacement': '\n'.join(module_rules),
			'files': [ 'mk/libtranscript.in' ]
		},
		{
			'tag': '<OBJECTS>',
			'replacement': " ".join(mkdist.sources_to_objects(mkdist.include_by_regex(mkdist.sources, '^src\.util/linkltc/'), '\.c$', '.o')),
			'files': [ 'mk/linkltc.in' ]
		},
		{
			'tag': '<OBJECTS>',
			'replacement': " ".join(mkdist.sources_to_objects(mkdist.include_by_regex(mkdist.sources, '^src\.util/ucm2ltc/'), '\.cc?$', '.o')),
			'files': [ 'mk/ucm2ltc.in' ]
		},
		{
			'tag': '<VERSIONINFO>',
			'replacement': versioninfo,
			'files': [ 'mk/libtranscript.in' ]
		},
		{
			'tag': '<LIBVERSION>',
			'replacement': libversion,
			'files': [ 'Makefile.in', 'mk/*.in' ]
		},
		{
			'tag': '.objects/',
			'replacement': '',
			'files': [ 'src.util/ucm2ltc/ucmparser.cc' ]
		}
	]

def finalize(mkdist):
	os.symlink('.', os.path.join(mkdist.topdir, 'src', 'transcript'))
